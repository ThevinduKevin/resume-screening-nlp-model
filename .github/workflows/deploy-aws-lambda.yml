name: AWS Lambda Benchmark

on:
  workflow_dispatch:

env:
  DOCKER_IMAGE: ml-resume-lambda
  DOCKER_TAG: latest

jobs:
  aws-lambda:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          lfs: false
        env:
          GIT_LFS_SKIP_SMUDGE: '1'

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_CREDENTIALS }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Deploy Lambda Infrastructure (Phase 1 - ECR only)
        working-directory: terraform/aws-lambda
        run: |
          terraform init
          gsutil rm gs://resume-screening-ml-terraform-bucket/aws-lambda/default.tflock 2>/dev/null || true
          # Remove any stale CloudWatch log groups from state (resources no longer managed by Terraform)
          terraform state rm aws_cloudwatch_log_group.lambda_logs 2>/dev/null || true
          terraform state rm aws_cloudwatch_log_group.api_gw_logs 2>/dev/null || true
          terraform state rm aws_iam_user_policy.terraform_cloudwatch_tags 2>/dev/null || true
          # Import existing resources into fresh state (they may exist from previous runs)
          terraform import aws_ecr_repository.lambda_repo ml-resume-lambda 2>/dev/null || true
          terraform import aws_iam_role.lambda_role ml-resume-lambda-role 2>/dev/null || true
          terraform import aws_iam_role_policy_attachment.lambda_basic ml-resume-lambda-role/arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole 2>/dev/null || true
          # First create just the ECR repository (skip refresh to avoid stale CloudWatch state errors)
          terraform apply -auto-approve -refresh=false -target=aws_ecr_repository.lambda_repo

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and Push Docker Image to ECR
        working-directory: terraform/aws-lambda
        run: |
          ECR_REPO=$(terraform output -raw ecr_repository_url)
          cd ../..
          # Build Lambda-specific image
          docker build --provenance=false --sbom=false -f Dockerfile.lambda -t $ECR_REPO:$DOCKER_TAG .
          docker push $ECR_REPO:$DOCKER_TAG
          echo "IMAGE_URL=$ECR_REPO:$DOCKER_TAG" >> $GITHUB_ENV

      - name: Deploy Lambda Infrastructure (Phase 2 - Full)
        working-directory: terraform/aws-lambda
        run: |
          terraform apply -auto-approve -refresh=false
          FUNCTION_URL=$(terraform output -raw function_url)
          echo "FUNCTION_URL=$FUNCTION_URL" >> $GITHUB_ENV
          echo "API_URL=$FUNCTION_URL" >> $GITHUB_ENV

      - name: Update Lambda with new image
        working-directory: terraform/aws-lambda
        run: |
          FUNCTION_NAME=$(terraform output -raw function_name)
          ECR_REPO=$(terraform output -raw ecr_repository_url)
          aws lambda update-function-code \
            --function-name $FUNCTION_NAME \
            --image-uri $ECR_REPO:$DOCKER_TAG
          echo "Waiting for Lambda update to complete..."
          aws lambda wait function-updated --function-name $FUNCTION_NAME
          echo "Lambda function updated successfully"

      - name: Ensure Lambda Function URL is publicly accessible
        working-directory: terraform/aws-lambda
        run: |
          FUNCTION_NAME=$(terraform output -raw function_name)
          # Remove existing permission if any, then re-add to ensure it's correct
          aws lambda remove-permission --function-name $FUNCTION_NAME --statement-id FunctionURLAllowPublicAccess 2>/dev/null || true
          aws lambda add-permission \
            --function-name $FUNCTION_NAME \
            --statement-id FunctionURLAllowPublicAccess \
            --action lambda:InvokeFunctionUrl \
            --principal "*" \
            --function-url-auth-type NONE
          echo "Public access permission granted"

      - name: Debug Lambda Function State
        working-directory: terraform/aws-lambda
        run: |
          FUNCTION_NAME=$(terraform output -raw function_name)
          echo "=== Lambda Function Configuration ==="
          aws lambda get-function-configuration --function-name $FUNCTION_NAME --query '{State:State,LastUpdateStatus:LastUpdateStatus,StateReason:StateReasonCode,Timeout:Timeout,MemorySize:MemorySize}' --output table
          echo ""
          echo "=== Function URL Configuration ==="
          aws lambda get-function-url-config --function-name $FUNCTION_NAME --query '{AuthType:AuthType,Cors:Cors}' --output table 2>/dev/null || echo "No function URL config found"
          echo ""
          echo "=== Resource Policy ==="
          aws lambda get-policy --function-name $FUNCTION_NAME --query 'Policy' --output text 2>/dev/null | python3 -m json.tool || echo "No resource policy found"

      - name: Wait for API to be ready
        run: |
          # Wait for API Gateway to propagate
          echo "Waiting for Lambda API to be ready at $FUNCTION_URL..."
          for i in {1..30}; do
            HTTP_CODE=$(curl -s -o /tmp/response.txt -w "%{http_code}" -L "${FUNCTION_URL}ping" 2>/dev/null || echo "000")
            if [ "$HTTP_CODE" = "200" ]; then
              echo "API Gateway is UP (/ping success)! Now checking /health..."
              curl -s -L "${FUNCTION_URL}health"
              break
            fi
            echo "Attempt $i/30: HTTP $HTTP_CODE, waiting 10s..."
            cat /tmp/response.txt
            echo ""
            sleep 10
          done
          curl -v "${FUNCTION_URL}health" 2>&1 || true
          echo "TARGET_HOST=$FUNCTION_URL" >> $GITHUB_ENV

      - name: Measure cold starts
        env:
          RESULTS_DIR: results/aws-lambda
        run: |
          set -e
          mkdir -p $RESULTS_DIR
          python3 -m venv test-env
          source test-env/bin/activate
          pip install requests
          # Measure cold starts (3 tests with 90 second wait between)
          python scripts/measure_cold_starts.py "$FUNCTION_URL" "$RESULTS_DIR/cold_start_metrics.csv" 3 90

      - name: Run Locust tests
        env:
          RESULTS_DIR: results/aws-lambda
        run: |
          set -e
          mkdir -p $RESULTS_DIR
          python3 -m venv locust-env
          source locust-env/bin/activate
          pip install --upgrade pip
          pip install locust psutil zope-event
          python scripts/collect_metrics.py &
          # Use Lambda Function URL
          export TARGET_IP=$(echo "$FUNCTION_URL" | sed 's|https://||' | sed 's|http://||' | sed 's|/$||')
          export TARGET_PROTOCOL="https"
          bash scripts/run_locust.sh
          mv results/locust_*.csv $RESULTS_DIR/ || true
          mv results/locust_*.log $RESULTS_DIR/ || true
          mv results/system_metrics.csv $RESULTS_DIR/ || true

      - name: Collect Lambda metrics
        if: always()
        env:
          RESULTS_DIR: results/aws-lambda
        working-directory: terraform/aws-lambda
        run: |
          mkdir -p ../../$RESULTS_DIR
          FUNCTION_NAME=$(terraform output -raw function_name)
          # Get Lambda metrics from CloudWatch
          aws cloudwatch get-metric-statistics \
            --namespace AWS/Lambda \
            --metric-name Duration \
            --dimensions Name=FunctionName,Value=$FUNCTION_NAME \
            --start-time $(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%SZ) \
            --end-time $(date -u +%Y-%m-%dT%H:%M:%SZ) \
            --period 60 \
            --statistics Average Maximum Minimum \
            > ../../$RESULTS_DIR/lambda_duration_metrics.json || true
          
          aws cloudwatch get-metric-statistics \
            --namespace AWS/Lambda \
            --metric-name Invocations \
            --dimensions Name=FunctionName,Value=$FUNCTION_NAME \
            --start-time $(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%SZ) \
            --end-time $(date -u +%Y-%m-%dT%H:%M:%SZ) \
            --period 60 \
            --statistics Sum \
            > ../../$RESULTS_DIR/lambda_invocations_metrics.json || true
          
          aws cloudwatch get-metric-statistics \
            --namespace AWS/Lambda \
            --metric-name ConcurrentExecutions \
            --dimensions Name=FunctionName,Value=$FUNCTION_NAME \
            --start-time $(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%SZ) \
            --end-time $(date -u +%Y-%m-%dT%H:%M:%SZ) \
            --period 60 \
            --statistics Maximum \
            > ../../$RESULTS_DIR/lambda_concurrent_metrics.json || true

      - name: Upload results to Google Sheets
        if: success()
        run: |
          pip install gspread google-auth
          python scripts/upload_serverless_to_sheets.py aws-lambda results/aws-lambda

      - name: Destroy AWS Lambda Infrastructure
        if: always()
        working-directory: terraform/aws-lambda
        run: |
          gsutil rm gs://resume-screening-ml-terraform-bucket/aws-lambda-v2/default.tflock 2>/dev/null || true
          terraform destroy -auto-approve

      - name: Upload AWS Lambda results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: aws-lambda-results
          path: results/aws-lambda/
